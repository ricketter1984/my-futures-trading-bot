import pandas as pd
import numpy as np
from datetime import timedelta # NEW Import - make sure this is added

class Backtester:
    def __init__(self, data, initial_capital=100000, commission_per_trade=0.0):
        """
        Initializes the backtester with historical market data and settings.

        Args:
            data (pd.DataFrame): Historical OHLCV data with DatetimeIndex.
            initial_capital (float): Starting capital for the backtest.
            commission_per_trade (float): Fixed commission cost per executed trade (entry and exit are separate trades).
        """
        self.data = data.copy() # Work with a copy of the data
        self.initial_capital = initial_capital
        self.commission_per_trade = commission_per_trade
        
        self.equity_curve = pd.Series(dtype=float) # Stores portfolio value over time
        self.trade_log = [] # Stores details of each completed trade

        self._current_capital = initial_capital
        self._current_position_size = 0 # Number of units held
        self._current_position_type = None # 'long', 'short', or None
        self._entry_price = 0.0
        self._entry_date = None
        self._in_trade = False

    def run_backtest(self, signals_df):
        """
        Main method to run the backtest based on generated signals.
        
        Args:
            signals_df (pd.DataFrame): DataFrame of trade signals generated by the strategy.
                                       Must have 'timestamp', 'type', 'price'.
        """
        if signals_df.empty:
            print("No signals provided to the backtester.")
            return

        # Ensure signals are sorted by timestamp
        signals_df = signals_df.sort_values(by='timestamp').reset_index(drop=True)

        # Initialize equity curve with initial capital at the first data point's date
        if not self.data.empty:
            first_data_date = self.data.index.min()
            self.equity_curve = pd.Series(self.initial_capital, index=[first_data_date])
        else:
            print("Historical data is empty. Cannot run backtest.")
            return
            
        # Iterate through each signal
        for index, signal_row in signals_df.iterrows():
            self._process_signal(signal_row)

        # If a position is still open at the end, simulate closing it at the last price
        if self._in_trade:
            last_data_point = self.data.iloc[-1]
            exit_price = last_data_point['Close']
            exit_date = last_data_point.name # Get the timestamp
            
            # Simulate exit signal
            synthetic_exit_signal = {
                'timestamp': exit_date,
                'type': f"exit_{self._current_position_type}", # e.g., 'exit_long'
                'price': exit_price,
                'reason': 'end_of_backtest'
            }
            self._process_signal(pd.Series(synthetic_exit_signal))

        # Ensure equity curve has continuous time index from data
        if not self.data.empty and not self.equity_curve.empty:
            # Reindex to data's full date range and forward-fill values
            full_date_range = pd.date_range(start=self.data.index.min(), end=self.data.index.max(), freq=pd.infer_freq(self.data.index))
            self.equity_curve = self.equity_curve.reindex(full_date_range, method='ffill')
            self.equity_curve = self.equity_curve.fillna(self.initial_capital) # Fill initial NaNs
        
        print(f"Backtest run complete. Total trades: {len(self.trade_log)}")


    def _process_signal(self, signal_row):
        """
        Handles an individual trade signal (entry or exit).
        Simulates trade execution, calculates P&L, and updates equity.
        """
        signal_type = signal_row['type']
        signal_price = signal_row['price']
        signal_date = signal_row['timestamp']

        # Ensure equity curve is updated up to the current signal date
        # This handles cases where there are gaps between signals
        if not self.equity_curve.empty and signal_date > self.equity_curve.index[-1]:
            # Get data up to the signal date to ensure correct ffill
            data_before_signal = self.data.loc[:signal_date].index
            last_equity_date = self.equity_curve.index[-1]
            
            # Find dates between last equity update and current signal
            dates_to_fill = data_before_signal[data_before_signal > last_equity_date]
            
            if not dates_to_fill.empty:
                temp_series = pd.Series(self.equity_curve.iloc[-1], index=dates_to_fill)
                self.equity_curve = pd.concat([self.equity_curve, temp_series]).sort_index()

        # --- Entry Logic ---
        if signal_type == 'entry_long' and not self._in_trade:
            # Calculate position size: Assume full capital allocation for simplicity
            # In a real scenario, you'd calculate based on risk per trade, volatility, etc.
            self._current_position_size = int(self._current_capital / signal_price) # Buy whole units
            if self._current_position_size == 0:
                print(f"Not enough capital to buy at {signal_date}. Capital: {self._current_capital:.2f}, Price: {signal_price:.2f}")
                return # Cannot open position

            self._current_capital -= (self._current_position_size * signal_price) # Deduct cost of shares
            self._current_capital -= self.commission_per_trade # Deduct commission
            
            self._entry_price = signal_price
            self._entry_date = signal_date
            self._current_position_type = 'long'
            self._in_trade = True
            
            # Update equity curve (capital + value of open position)
            self.equity_curve.loc[signal_date] = self._current_capital + (self._current_position_size * signal_price)
            print(f"[{signal_date}] ENTER LONG: {self._current_position_size} units at {signal_price:.2f}. New Capital: {self._current_capital:.2f}")

        elif signal_type == 'entry_short' and not self._in_trade:
            # Calculate position size: Assume full capital allocation for simplicity
            self._current_position_size = int(self._current_capital / signal_price) # Short whole units
            if self._current_position_size == 0:
                print(f"Not enough capital to short at {signal_date}. Capital: {self._current_capital:.2f}, Price: {signal_price:.2f}")
                return # Cannot open position

            self._current_capital -= self.commission_per_trade # Deduct commission (borrowing cost is usually separate)
            # Shorting increases 'cash' but creates a liability.
            # For simplicity, we'll track 'capital' as available cash + P&L from closed trades.
            # The value of the short position is tracked implicitly by _current_position_size and _entry_price.

            self._entry_price = signal_price
            self._entry_date = signal_date
            self._current_position_type = 'short'
            self._in_trade = True
            
            # Update equity curve (capital + value of open position - liability)
            # For short, equity is capital + (self._entry_price - signal_price) * self._current_position_size
            self.equity_curve.loc[signal_date] = self._current_capital + (self._current_position_size * (self._entry_price - signal_price))
            print(f"[{signal_date}] ENTER SHORT: {self._current_position_size} units at {signal_price:.2f}. New Capital: {self._current_capital:.2f}")

        # --- Exit Logic ---
        elif signal_type == 'exit_long' and self._in_trade and self._current_position_type == 'long':
            pnl = (signal_price - self._entry_price) * self._current_position_size
            self._current_capital += (self._current_position_size * signal_price) # Add back value of shares
            self._current_capital -= self.commission_per_trade # Deduct commission
            
            self.trade_log.append({
                'entry_date': self._entry_date,
                'exit_date': signal_date,
                'type': 'long',
                'entry_price': self._entry_price,
                'exit_price': signal_price,
                'position_size': self._current_position_size,
                'pnl': pnl - (self.commission_per_trade * 2), # Total P&L including both commissions
                'entry_capital': self.equity_curve.loc[self._entry_date] if self._entry_date in self.equity_curve.index else self.initial_capital, # Capital at entry
                'exit_reason': signal_row.get('reason', 'strategy_exit')
            })
            
            self._in_trade = False
            self._current_position_size = 0
            self._current_position_type = None
            self._entry_price = 0.0
            self._entry_date = None

            # Update equity curve
            self.equity_curve.loc[signal_date] = self._current_capital
            print(f"[{signal_date}] EXIT LONG: PnL: {pnl:.2f}. New Capital: {self._current_capital:.2f}")

        elif signal_type == 'exit_short' and self._in_trade and self._current_position_type == 'short':
            pnl = (self._entry_price - signal_price) * self._current_position_size
            self._current_capital += (self._current_position_size * self._entry_price) # Account for initial short value
            self._current_capital += pnl # Add profit (or subtract loss)
            self._current_capital -= self.commission_per_trade # Deduct commission
            
            self.trade_log.append({
                'entry_date': self._entry_date,
                'exit_date': signal_date,
                'type': 'short',
                'entry_price': self._entry_price,
                'exit_price': signal_price,
                'position_size': self._current_position_size,
                'pnl': pnl - (self.commission_per_trade * 2), # Total P&L including both commissions
                'entry_capital': self.equity_curve.loc[self._entry_date] if self._entry_date in self.equity_curve.index else self.initial_capital, # Capital at entry
                'exit_reason': signal_row.get('reason', 'strategy_exit')
            })

            self._in_trade = False
            self._current_position_size = 0
            self._current_position_type = None
            self._entry_price = 0.0
            self._entry_date = None
            
            # Update equity curve
            self.equity_curve.loc[signal_date] = self._current_capital
            print(f"[{signal_date}] EXIT SHORT: PnL: {pnl:.2f}. New Capital: {self._current_capital:.2f}")

        # --- Handle cases where signals are out of order or invalid ---
        elif self._in_trade and (
            (signal_type == 'entry_long' and self._current_position_type == 'long') or
            (signal_type == 'entry_short' and self._current_position_type == 'short')
        ):
            print(f"[{signal_date}] WARNING: Attempted to {signal_type} while already in a {self._current_position_type} position. Signal ignored.")
        elif not self._in_trade and (signal_type == 'exit_long' or signal_type == 'exit_short'):
            print(f"[{signal_date}] WARNING: Attempted to {signal_type} while not in a position. Signal ignored.")

        # Update equity curve for dates between signals where no trades occurred
        # This is crucial for accurate drawdown calculation later
        if self._in_trade:
            # If in a trade, update the equity based on current market price
            # Find the latest date in the equity curve before the current signal_date
            last_equity_date = self.equity_curve.index[-1] if not self.equity_curve.empty else self.data.index.min()
            
            # Get data points between last equity update and current signal date
            # Ensure we only consider data points *after* the last equity update
            relevant_data_slice = self.data.loc[last_equity_date:signal_date].iloc[1:] # Exclude last_equity_date itself
            
            for date_idx, row_data in relevant_data_slice.iterrows():
                if self._current_position_type == 'long':
                    current_equity = self._current_capital + (self._current_position_size * row_data['Close'])
                elif self._current_position_type == 'short':
                    current_equity = self._current_capital + (self._current_position_size * (self._entry_price - row_data['Close']))
                else: # Should not happen if _in_trade is True
                    current_equity = self._current_capital
                self.equity_curve.loc[date_idx] = current_equity
        else:
            # If not in trade, equity remains _current_capital
            # Fill forward for any dates between trades
            last_equity_date = self.equity_curve.index[-1] if not self.equity_curve.empty else self.data.index.min()
            relevant_data_slice = self.data.loc[last_equity_date:signal_date].iloc[1:]
            
            for date_idx, row_data in relevant_data_slice.iterrows():
                self.equity_curve.loc[date_idx] = self._current_capital

        # Ensure the latest signal date is always reflected in the equity curve
        if signal_date not in self.equity_curve.index:
             self.equity_curve.loc[signal_date] = self._current_capital # Or current equity if in trade
             if self._in_trade:
                if self._current_position_type == 'long':
                    self.equity_curve.loc[signal_date] = self._current_capital + (self._current_position_size * signal_price)
                elif self._current_position_type == 'short':
                    self.equity_curve.loc[signal_date] = self._current_capital + (self._current_position_size * (self._entry_price - signal_price))
        
        # Sort equity curve by index to maintain time series order
        self.equity_curve = self.equity_curve.sort_index()

    def get_results(self):
        """
        Returns the trade log and equity curve as DataFrames.
        """
        trade_log_df = pd.DataFrame(self.trade_log)
        if not trade_log_df.empty:
            trade_log_df['entry_date'] = pd.to_datetime(trade_log_df['entry_date'])
            trade_log_df['exit_date'] = pd.to_datetime(trade_log_df['exit_date'])
            
            # Calculate derived metrics for trade log
            trade_log_df['pnl_percent'] = (trade_log_df['pnl'] / trade_log_df['entry_capital']) * 100
            trade_log_df['duration_days'] = (trade_log_df['exit_date'] - trade_log_df['entry_date']).dt.days
        
        return trade_log_df, self.equity_curve

    def calculate_metrics(self, trade_log_df, equity_curve_series, risk_free_rate=0.0):
        """
        Calculates and returns a dictionary of key performance metrics.
        
        Args:
            trade_log_df (pd.DataFrame): DataFrame of completed trades.
            equity_curve_series (pd.Series): Time series of portfolio equity.
            risk_free_rate (float): Annual risk-free rate for Sharpe Ratio calculation (e.g., 0.02 for 2%).
        
        Returns:
            dict: A dictionary containing various performance metrics.
        """
        metrics = {}

        if equity_curve_series.empty or len(equity_curve_series) < 2:
            print("Equity curve too short or empty for metric calculation.")
            return {m: 0.0 for m in ['total_return', 'annualized_return', 'max_drawdown', 
                                     'sharpe_ratio', 'win_rate', 'profit_factor', 
                                     'avg_win_percent', 'avg_loss_percent']}

        # Total Return
        total_return = (equity_curve_series.iloc[-1] / equity_curve_series.iloc[0]) - 1
        metrics['total_return'] = total_return * 100

        # Annualized Return
        # Assuming daily data for frequency calculation
        trading_days_per_year = 252 # Typical for equities/futures
        num_years = (equity_curve_series.index[-1] - equity_curve_series.index[0]).days / 365.25
        if num_years > 0:
            metrics['annualized_return'] = ((1 + total_return)**(1/num_years) - 1) * 100
        else:
            metrics['annualized_return'] = 0.0

        # Max Drawdown
        roll_max = equity_curve_series.expanding(min_periods=1).max()
        daily_drawdown = equity_curve_series / roll_max - 1.0
        max_drawdown = daily_drawdown.min()
        metrics['max_drawdown'] = max_drawdown * 100

        # Sharpe Ratio
        # Assuming daily returns for equity curve
        returns = equity_curve_series.pct_change().dropna()
        if returns.std() != 0:
            daily_risk_free_rate = (1 + risk_free_rate)**(1/trading_days_per_year) - 1
            excess_returns = returns - daily_risk_free_rate
            sharpe_ratio = np.sqrt(trading_days_per_year) * (excess_returns.mean() / returns.std())
            metrics['sharpe_ratio'] = sharpe_ratio
        else:
            metrics['sharpe_ratio'] = np.nan # Or 0.0 if no volatility

        if trade_log_df.empty:
            metrics['win_rate'] = 0.0
            metrics['profit_factor'] = 0.0
            metrics['avg_win_percent'] = 0.0
            metrics['avg_loss_percent'] = 0.0
            return metrics

        # Win Rate
        winning_trades = trade_log_df[trade_log_df['pnl'] > 0]
        losing_trades = trade_log_df[trade_log_df['pnl'] < 0]
        total_trades = len(trade_log_df)
        
        metrics['win_rate'] = (len(winning_trades) / total_trades) * 100 if total_trades > 0 else 0.0

        # Profit Factor (Gross Profits / Gross Losses)
        gross_profits = winning_trades['pnl'].sum()
        gross_losses = np.abs(losing_trades['pnl'].sum()) # Absolute value of losses
        
        if gross_losses > 0:
            metrics['profit_factor'] = gross_profits / gross_losses
        else:
            metrics['profit_factor'] = np.inf if gross_profits > 0 else 0.0 # Infinite if no losses

        # Average Win / Average Loss (in percentage terms)
        metrics['avg_win_percent'] = winning_trades['pnl_percent'].mean() if not winning_trades.empty else 0.0
        metrics['avg_loss_percent'] = losing_trades['pnl_percent'].mean() if not losing_trades.empty else 0.0 # Will be negative

        return metrics 